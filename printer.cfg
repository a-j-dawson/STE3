# This file contains common pin mappings for the BigTreeTech Octopus
# and Octopus Pro boards. To use this config, start by identifying the
# micro-controller on the board - it may be an STM32F446, STM32F429,
# or an STM32H723.  Select the appropriate micro-controller in "make
# menuconfig" and select "Enable low-level configuration options". For
# STM32F446 boards the firmware should be compiled with a "32KiB
# bootloader" and a "12MHz crystal" clock reference. For STM32F429
# boards use a "32KiB bootloader" and an "8MHz crystal". For STM32H723
# boards use a "128KiB bootloader" and a "25Mhz crystal".

# See docs/Config_Reference.md for a description of parameters.

[include mainsail.cfg]

[gcode_macro _CLIENT_VARIABLE]
variable_use_custom_pos   : True ; use custom park coordinates for x,y [True/False]
variable_custom_park_x    : 230   ; custom x position; value must be within your defined min and max of X
variable_custom_park_y    : 230   ; custom y position; value must be within your defined min and max of Y
#variable_custom_park_dz   : 2.0   ; custom dz value; the value in mm to lift the nozzle when move to park position
#variable_retract          : 1.0   ; the value to retract while PAUSE
#variable_cancel_retract   : 5.0   ; the value to retract while CANCEL_PRINT
#variable_speed_retract    : 35.0  ; retract speed in mm/s
#variable_unretract        : 1.0   ; the value to unretract while RESUME
#variable_speed_unretract  : 35.0  ; unretract speed in mm/s
#variable_speed_hop        : 15.0  ; z move speed in mm/s
#variable_speed_move       : 100.0 ; move speed in mm/s
#variable_park_at_cancel   : False ; allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
#variable_park_at_cancel_x : None  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
#variable_park_at_cancel_y : None  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
## !!! Caution [firmware_retraction] must be defined in the printer.cfg if you set use_fw_retract: True !!!
#variable_use_fw_retract   : False ; use fw_retraction instead of the manual version [True/False]
#variable_idle_timeout     : 0     ; time in sec until idle_timeout kicks in. Value 0 means that no value will be set or restored
#variable_runout_sensor    : ""    ; If a sensor is defined, it will be used to cancel the execution of RESUME in case no filament is detected.
##                                   Specify the config name of the runout sensor e.g "filament_switch_sensor runout". Hint use the same as in your printer.cfg
gcode:

[virtual_sdcard]
path: /home/pi/printer_data/gcodes
on_error_gcode: CANCEL_PRINT
[display_status]
[include macros.cfg]

##################################################################################################################################################
##################################################################################################################################################
############################################################ STEPPER DRIVERS #####################################################################
##################################################################################################################################################
##################################################################################################################################################

# Driver0
[stepper_x]
step_pin: PF13
#   Step GPIO pin (triggered high). This parameter must be provided.
dir_pin: !PF12
#   Direction GPIO pin (high indicates positive direction). This
#   parameter must be provided.
enable_pin: !PF14
#   Enable pin (default is enable high; use ! to indicate enable
#   low). If this parameter is not provided then the stepper motor
#   driver must always be enabled.
microsteps: 16
#   The number of microsteps the stepper motor driver uses. This
#   parameter must be provided.
#full_steps_per_rotation: 200
#   The number of full steps for one rotation of the stepper motor.
#   Set this to 200 for a 1.8 degree stepper motor or set to 400 for a
#   0.9 degree motor. The default is 200.
#gear_ratio:
#   The gear ratio if the stepper motor is connected to the axis via a
#   gearbox. For example, one may specify "5:1" if a 5 to 1 gearbox is
#   in use. If the axis has multiple gearboxes one may specify a comma
#   separated list of gear ratios (for example, "57:11, 2:1"). If a
#   gear_ratio is specified then rotation_distance specifies the
#   distance the axis travels for one full rotation of the final gear.
#   The default is to not use a gear ratio.
#step_pulse_duration:
#   The minimum time between the step pulse signal edge and the
#   following "unstep" signal edge. This is also used to set the
#   minimum time between a step pulse and a direction change signal.
#   The default is 0.000000100 (100ns) for TMC steppers that are
#   configured in UART or SPI mode, and the default is 0.000002 (which
#   is 2us) for all other steppers.
rotation_distance: 40
#   Distance (in mm) that the axis travels with one full rotation of
#   the stepper motor (or final gear if gear_ratio is specified).
#   This parameter must be provided.
endstop_pin: PG6
#   Endstop switch detection pin. If this endstop pin is on a
#   different mcu than the stepper motor then it enables "multi-mcu
#   homing". This parameter must be provided for the X, Y, and Z
#   steppers on cartesian style printers.
position_endstop: 0
#   Location of the endstop (in mm). This parameter must be provided
#   for the X, Y, and Z steppers on cartesian style printers.
#   For BLTouch change to distance moved for nozzle to be in bed corner
position_max: 245
position_min: 0
#   Minimum valid distance (in mm) the user may command the stepper to
#   move to.  The default is 0mm.
#   Set to same as endstop for BLTouch
homing_speed: 60
#   Maximum velocity (in mm/s) of the stepper when homing. The default
#   is 5mm/s.
second_homing_speed: 20
#   Velocity (in mm/s) of the stepper when performing the second home.
#   The default is homing_speed/2.
#homing_retract_dist: 5.0
#   Distance to backoff (in mm) before homing a second time during
#   homing. Set this to zero to disable the second home. The default
#   is 5mm.
#homing_retract_speed:
#   Speed to use on the retract move after homing in case this should
#   be different from the homing speed, which is the default for this
#   parameter
#homing_positive_dir:
#   If true, homing will cause the stepper to move in a positive
#   direction (away from zero); if false, home towards zero. It is
#   better to use the default than to specify this parameter. The
#   default is true if position_endstop is near position_max and false
#   if near position_min.

##################################################################################################################################################
######################################################################### Y- AXIS ################################################################
##################################################################################################################################################

# Driver1
[stepper_y]
step_pin: PG0
dir_pin: !PG1
enable_pin: !PF15
microsteps: 16
rotation_distance: 40
endstop_pin: PG9
position_endstop: 0
#   For BLTouch change to distance moved for nozzle to be in bed corner
position_max: 250
position_min: 0  #same as endstop for BLTouch
homing_speed: 60
second_homing_speed: 20

##################################################################################################################################################
######################################################################### Z- AXIS ################################################################
##################################################################################################################################################

# Driver2
#[stepper_z]
#step_pin: PF11
#dir_pin: PG3
#enable_pin: !PG5
#microsteps: 16
#rotation_distance: 8
#endstop_pin: PG10      #set as "probe:z_virtual_endstop" for BLTouch
#position_endstop: 0.0  #need to comment out for BLTouch
#position_max: 250
#position_min: -5      #need for BLTouch

[stepper_z]
step_pin: PF11
dir_pin: !PG3
enable_pin: !PG5
microsteps: 16
rotation_distance: 40
gear_ratio: 80:16
full_steps_per_rotation: 200 #200 for 1.8 degree, 400 for 0.9 degree
endstop_pin: PG11 #probe:z_virtual_endstop #PG10   
position_max: 250
position_min: -8
position_endstop: 1.2
homing_speed: 25
homing_retract_dist: 5.0
# Distance to backoff (in mm) before homing a second time during
# homing. Set this to zero to disable the second home. The default
# is 5mm.
homing_retract_speed: 10
# Speed to use on the retract move after homing in case this should
# be different from the homing speed, which is the default for this
# parameter
second_homing_speed: 5
# Velocity (in mm/s) of the stepper when performing the second home.
# The default is homing_speed/2.
#position_endstop: 0

##################################################################################################################################################

# Driver3
# The Octopus only has 4 heater outputs which leaves an extra stepper
# This can be used for a second Z stepper, dual_carriage, extruder co-stepper,
# or other accesory such as an MMU

[stepper_z1]
step_pin: PG4
dir_pin: !PC1
enable_pin: !PA0
microsteps: 16
rotation_distance: 40
gear_ratio: 80:16
full_steps_per_rotation: 200 #200 for 1.8 degree, 400 for 0.9 degree
#endstop_pin: PG11

##################################################################################################################################################
############################################################### EXTRUDER #########################################################################
##################################################################################################################################################

# Driver4
[extruder]
step_pin: PF9
dir_pin: PF10
enable_pin: !PG2
microsteps: 16
#   The number of microsteps the stepper motor driver uses. This
#   parameter must be provided.
rotation_distance: 47.088
#   Distance (in mm) that the axis travels with one full rotation of
#   the stepper motor (or final gear if gear_ratio is specified).
#   This parameter must be provided.
#full_steps_per_rotation:
#   The number of full steps for one rotation of the stepper motor.
#   Set this to 200 for a 1.8 degree stepper motor or set to 400 for a
#   0.9 degree motor. The default is 200.
gear_ratio: 9:1
#   The gear ratio if the stepper motor is connected to the axis via a
#   gearbox. For example, one may specify "5:1" if a 5 to 1 gearbox is
#   in use. If the axis has multiple gearboxes one may specify a comma
#   separated list of gear ratios (for example, "57:11, 2:1"). If a
#   gear_ratio is specified then rotation_distance specifies the
#   distance the axis travels for one full rotation of the final gear.
#   The default is to not use a gear ratio.
#   See the "stepper" section for a description of the above
#   parameters. If none of the above parameters are specified then no
#   stepper will be associated with the nozzle hotend (though a
#   SYNC_EXTRUDER_MOTION command may associate one at run-time).
nozzle_diameter: 0.400
#   Diameter of the nozzle orifice (in mm). This parameter must be
#   provided.
filament_diameter: 1.750
#   The nominal diameter of the raw filament (in mm) as it enters the
#   extruder. This parameter must be provided.
#max_extrude_cross_section:
#   Maximum area (in mm^2) of an extrusion cross section (eg,
#   extrusion width multiplied by layer height). This setting prevents
#   excessive amounts of extrusion during relatively small XY moves.
#   If a move requests an extrusion rate that would exceed this value
#   it will cause an error to be returned. The default is: 4.0 *
#   nozzle_diameter^2
#instantaneous_corner_velocity: 1.000
#   The maximum instantaneous velocity change (in mm/s) of the
#   extruder during the junction of two moves. The default is 1mm/s.
max_extrude_only_distance: 101
#   Maximum length (in mm of raw filament) that a retraction or
#   extrude-only move may have. If a retraction or extrude-only move
#   requests a distance greater than this value it will cause an error
#   to be returned. The default is 50mm.
#max_extrude_only_velocity:
#max_extrude_only_accel:
#   Maximum velocity (in mm/s) and acceleration (in mm/s^2) of the
#   extruder motor for retractions and extrude-only moves. These
#   settings do not have any impact on normal printing moves. If not
#   specified then they are calculated to match the limit an XY
#   printing move with a cross section of 4.0*nozzle_diameter^2 would
#   have.
pressure_advance: 1.24 # was 0.24
#   The amount of raw filament to push into the extruder during
#   extruder acceleration. An equal amount of filament is retracted
#   during deceleration. It is measured in millimeters per
#   millimeter/second. The default is 0, which disables pressure
#   advance.
#pressure_advance_smooth_time: 0.040
#   A time range (in seconds) to use when calculating the average
#   extruder velocity for pressure advance. A larger value results in
#   smoother extruder movements. This parameter may not exceed 200ms.
#   This setting only applies if pressure_advance is non-zero. The
#   default is 0.040 (40 milliseconds).
heater_pin: PA2 # HE0
#   PWM output pin controlling the heater. This parameter must be
#   provided.
#max_power: 1.0
#   The maximum power (expressed as a value from 0.0 to 1.0) that the
#   heater_pin may be set to. The value 1.0 allows the pin to be set
#   fully enabled for extended periods, while a value of 0.5 would
#   allow the pin to be enabled for no more than half the time. This
#   setting may be used to limit the total power output (over extended
#   periods) to the heater. The default is 1.0.
sensor_pin:  PF4 # T0
sensor_type: NTC 100K MGB18-104F39050L32 #Generic 3950 # was EPCOS 100K B57560G104F
#   Type of sensor - common thermistors are "EPCOS 100K B57560G104F",
#   "ATC Semitec 104GT-2", "ATC Semitec 104NT-4-R025H42G", "Generic
#   3950","Honeywell 100K 135-104LAG-J01", "NTC 100K MGB18-104F39050L32",
#   "SliceEngineering 450", and "TDK NTCG104LH104JT1". See the
#   "Temperature sensors" section for other sensors. This parameter
#   must be provided.
#pullup_resistor: 4700
#   The resistance (in ohms) of the pullup attached to the thermistor.
#   This parameter is only valid when the sensor is a thermistor. The
#   default is 4700 ohms.
#smooth_time: 1.0
#   A time value (in seconds) over which temperature measurements will
#   be smoothed to reduce the impact of measurement noise. The default
#   is 1 seconds.
#control: pid
#   Control algorithm (either pid or watermark). This parameter must
#   be provided.
#pid_Kp: 21.527
#pid_Ki: 1.063
#pid_Kd: 108.982
#   The proportional (pid_Kp), integral (pid_Ki), and derivative
#   (pid_Kd) settings for the PID feedback control system. Klipper
#   evaluates the PID settings with the following general formula:
#     heater_pwm = (Kp*error + Ki*integral(error) - Kd*derivative(error)) / 255
#   Where "error" is "requested_temperature - measured_temperature"
#   and "heater_pwm" is the requested heating rate with 0.0 being full
#   off and 1.0 being full on. Consider using the PID_CALIBRATE
#   command to obtain these parameters. The pid_Kp, pid_Ki, and pid_Kd
#   parameters must be provided for PID heaters.
#max_delta: 2.0
#   On 'watermark' controlled heaters this is the number of degrees in
#   Celsius above the target temperature before disabling the heater
#   as well as the number of degrees below the target before
#   re-enabling the heater. The default is 2 degrees Celsius.
#pwm_cycle_time: 0.100
#   Time in seconds for each software PWM cycle of the heater. It is
#   not recommended to set this unless there is an electrical
#   requirement to switch the heater faster than 10 times a second.
#   The default is 0.100 seconds.
min_extrude_temp: 170
#   The minimum temperature (in Celsius) at which extruder move
#   commands may be issued. The default is 170 Celsius.
min_temp: 0
max_temp: 270
#   The maximum range of valid temperatures (in Celsius) that the
#   heater must remain within. This controls a safety feature
#   implemented in the micro-controller code - should the measured
#   temperature ever fall outside this range then the micro-controller
#   will go into a shutdown state. This check can help detect some
#   heater and sensor hardware failures. Set this range just wide
#   enough so that reasonable temperatures do not result in an error.
#   These parameters must be provided.

#[filament_switch_sensor material_0]
#switch_pin: PG12

##################################################################################################################################################

# Driver5
#[extruder1]
#step_pin: PC13
#dir_pin: PF0
#enable_pin: !PF1
#heater_pin: PA3 # HE1
#sensor_pin: PF5 # T1
#...

#[filament_switch_sensor material_1]
#switch_pin: PG13

##################################################################################################################################################

# Driver6
#[extruder2]
#step_pin: PE2
#dir_pin: PE3
#enable_pin: !PD4
#heater_pin: PB10 # HE2
#sensor_pin: PF6 # T2
#...

#[filament_switch_sensor material_2]
#switch_pin: PG14

##################################################################################################################################################

# Driver7
#[extruder3]
#step_pin: PE6
#dir_pin: PA14
#enable_pin: !PE0
#heater_pin: PB11 # HE3
#sensor_pin: PF7 # T3
#...

#[filament_switch_sensor material_3]
#switch_pin: PG15

##################################################################################################################################################
################################################################# HEATER BED #####################################################################
##################################################################################################################################################

[heater_bed]
heater_pin: PA1
sensor_pin: PF3 # TB
sensor_type: Generic 3950 # was EPCOS 100K B57560G104F # was ATC Semitec 104GT-2
#control: pid
#pid_Kp: 54.027
#pid_Ki: 0.770
#pid_Kd: 948.182
min_temp: 0
max_temp: 130
#   See the "extruder" section for a description of the above parameters.

##################################################################################################################################################
##################################################################################################################################################
########################################################## BED LEVEL SUPPORT #####################################################################
##################################################################################################################################################
##################################################################################################################################################

[bed_screws] https://www.klipper3d.org/Manual_Level.html#adjusting-bed-leveling-screws
screw1: 30.5, 37
#   The X, Y coordinate of the first bed leveling screw. This is a
#   position to command the nozzle to that is directly above the bed
#   screw (or as close as possible while still being above the bed).
#   This parameter must be provided.
#screw1_name:
#   An arbitrary name for the given screw. This name is displayed when
#   the helper script runs. The default is to use a name based upon
#   the screw XY location.
#screw1_fine_adjust:
#   An X, Y coordinate to command the nozzle to so that one can fine
#   tune the bed leveling screw. The default is to not perform fine
#   adjustments on the bed screw.
screw2: 30.5, 207
#screw2_name:
#screw2_fine_adjust:
screw3: 204.5, 207
screw4: 204.5, 37
#   Additional bed leveling screws. At least three screws must be
#   defined.
#horizontal_move_z: 5
#   The height (in mm) that the head should be commanded to move to
#   when moving from one screw location to the next. The default is 5.
#probe_height: 0
#   The height of the probe (in mm) after adjusting for the thermal
#   expansion of bed and nozzle. The default is zero.
#speed: 50
#   The speed (in mm/s) of non-probing moves during the calibration.
#   The default is 50.
#probe_speed: 5
#   The speed (in mm/s) when moving from a horizontal_move_z position
#   to a probe_height position. The default is 5.


##################################################################################################################################################
##################################################################################################################################################

[z_tilt]
z_positions:
  0,117
  235,117
# A list of X, Y coordinates (one per line; subsequent lines
# indented) describing the location of each bed "pivot point". The
# "pivot point" is the point where the bed attaches to the given Z
# stepper. It is described using nozzle coordinates (the X, Y position
# of the nozzle if it could move directly above the point). The
# first entry corresponds to stepper_z, the second to stepper_z1,
# the third to stepper_z2, etc. This parameter must be provided.
points:
  8,96.5
  219,96.5
# A list of X, Y coordinates (one per line; subsequent lines
# indented) that should be probed during a Z_TILT_ADJUST command.
# Specify coordinates of the nozzle and be sure the probe is above
# the bed at the given nozzle coordinates. This parameter must be
# provided.
speed: 100
# The speed (in mm/s) of non-probing moves during the calibration.
# The default is 50.
horizontal_move_z: 15
# The height (in mm) that the head should be commanded to move to
# just prior to starting a probe operation. The default is 5.
retries: 10
# Number of times to retry if the probed points aren't within
# tolerance.
retry_tolerance: 0.01
# If retries are enabled then retry if largest and smallest probed
# points differ more than retry_tolerance. Note the smallest unit of
# change here would be a single step. However if you are probing
# more points than steppers then you will likely have a fixed
# minimum value for the range of probed points which you can learn
# by observing command output.

##################################################################################################################################################
##################################################################################################################################################

#[skew_correction] https://www.klipper3d.org/Skew_Correction.html


##################################################################################################################################################
##################################################################################################################################################
############################################################### G-CODE FEATURES ##################################################################
##################################################################################################################################################
##################################################################################################################################################

#[firmware_retraction]
#retract_length: 0
#   The length of filament (in mm) to retract when G10 is activated,
#   and to unretract when G11 is activated (but see
#   unretract_extra_length below). The default is 0 mm.
#retract_speed: 20
#   The speed of retraction, in mm/s. The default is 20 mm/s.
#unretract_extra_length: 0
#   The length (in mm) of *additional* filament to add when
#   unretracting.
#unretract_speed: 10
#   The speed of unretraction, in mm/s. The default is 10 mm/s.

##################################################################################################################################################
##################################################################################################################################################
######################################################### RESONANCE COMPENSATION #################################################################
##################################################################################################################################################
##################################################################################################################################################
# https://www.klipper3d.org/Resonance_Compensation.html

#[input_shaper]
#shaper_freq_x: 0
#   A frequency (in Hz) of the input shaper for X axis. This is
#   usually a resonance frequency of X axis that the input shaper
#   should suppress. For more complex shapers, like 2- and 3-hump EI
#   input shapers, this parameter can be set from different
#   considerations. The default value is 0, which disables input
#   shaping for X axis.
#shaper_freq_y: 0
#   A frequency (in Hz) of the input shaper for Y axis. This is
#   usually a resonance frequency of Y axis that the input shaper
#   should suppress. For more complex shapers, like 2- and 3-hump EI
#   input shapers, this parameter can be set from different
#   considerations. The default value is 0, which disables input
#   shaping for Y axis.
#shaper_freq_z: 0
#   A frequency (in Hz) of the input shaper for Z axis. The default
#   value is 0, which disables input shaping for Z axis.
#shaper_type: mzv
#   A type of the input shaper to use for all axes. Supported
#   shapers are zv, mzv, zvd, ei, 2hump_ei, and 3hump_ei. The default
#   is mzv input shaper.
#shaper_type_x:
#shaper_type_y:
#shaper_type_z:
#   If shaper_type is not set, these parameters can be used to
#   configure different input shapers for X, Y, and Z axes. The same
#   values are supported as for shaper_type parameter.
#damping_ratio_x: 0.1
#damping_ratio_y: 0.1
#damping_ratio_z: 0.1
#   Damping ratios of vibrations of X and Y axes used by input shapers
#   to improve vibration suppression. Default value is 0.1 which is a
#   good all-round value for most printers. In most circumstances this
#   parameter requires no tuning and should not be changed.

##################################################################################################################################################
##################################################################################################################################################
################################################################### FANS #########################################################################
##################################################################################################################################################
##################################################################################################################################################
[multi_pin cooling_fan_pins] #****************************************************************************************************************************** NEW
pins: PE5, PD12 #************************************************************************************************************************************************ NEW
#[fan_generic cooling_fan_right] #********************************************************************************************************************************* out
[fan]
#pin: PE5 #PA8 #**************************************************************************************************************************************************** out
pin: multi_pin:cooling_fan_pins
#   Output pin controlling the fan. This parameter must be provided.
max_power: 0.9
#   The maximum power (expressed as a value from 0.0 to 1.0) that the
#   pin may be set to. The value 1.0 allows the pin to be set fully
#   enabled for extended periods, while a value of 0.5 would allow the
#   pin to be enabled for no more than half the time. This setting may
#   be used to limit the total power output (over extended periods) to
#   the fan. If this value is less than 1.0 then fan speed requests
#   will be scaled between zero and max_power (for example, if
#   max_power is .9 and a fan speed of 80% is requested then the fan
#   power will be set to 72%). The default is 1.0.
#shutdown_speed: 0
#   The desired fan speed (expressed as a value from 0.0 to 1.0) if
#   the micro-controller software enters an error state. The default
#   is 0.
#cycle_time: 0.010
#   The amount of time (in seconds) for each PWM power cycle to the
#   fan. It is recommended this be 10 milliseconds or greater when
#   using software based PWM. The default is 0.010 seconds.
#hardware_pwm: False
#   Enable this to use hardware PWM instead of software PWM. Most fans
#   do not work well with hardware PWM, so it is not recommended to
#   enable this unless there is an electrical requirement to switch at
#   very high speeds. When using hardware PWM the actual cycle time is
#   constrained by the implementation and may be significantly
#   different than the requested cycle_time. The default is False.
kick_start_time: 0.500
#   Time (in seconds) to run the fan at full speed when either first
#   enabling or increasing it by more than 50% (helps get the fan
#   spinning). The default is 0.100 seconds.
#off_below: 0.0
#   The minimum input speed which will power the fan (expressed as a
#   value from 0.0 to 1.0). When a speed lower than off_below is
#   requested the fan will instead be turned off. This setting may be
#   used to prevent fan stalls and to ensure kick starts are
#   effective. The default is 0.0.
#
#   This setting should be recalibrated whenever max_power is adjusted.
#   To calibrate this setting, start with off_below set to 0.0 and the
#   fan spinning. Gradually lower the fan speed to determine the lowest
#   input speed which reliably drives the fan without stalls. Set
#   off_below to the duty cycle corresponding to this value (for
#   example, 12% -> 0.12) or slightly higher.
#tachometer_pin:
#   Tachometer input pin for monitoring fan speed. A pullup is generally
#   required. This parameter is optional.
#tachometer_ppr: 2
#   When tachometer_pin is specified, this is the number of pulses per
#   revolution of the tachometer signal. For a BLDC fan this is
#   normally half the number of poles. The default is 2.
#tachometer_poll_interval: 0.0015
#   When tachometer_pin is specified, this is the polling period of the
#   tachometer pin, in seconds. The default is 0.0015, which is fast
#   enough for fans below 10000 RPM at 2 PPR. This must be smaller than
#   30/(tachometer_ppr*rpm), with some margin, where rpm is the
#   maximum speed (in RPM) of the fan.
#enable_pin:
#   Optional pin to enable power to the fan. This can be useful for fans
#   with dedicated PWM inputs. Some of these fans stay on even at 0% PWM
#   input. In such a case, the PWM pin can be used normally, and e.g. a
#   ground-switched FET(standard fan pin) can be used to control power to
#   the fan.

##################################################################################################################################################
##################################################################################################################################################

[heater_fan fan1]
pin: PA8 #PE5 
#max_power:
#shutdown_speed:
#cycle_time:
#hardware_pwm:
#kick_start_time:
#off_below:
#tachometer_pin:
#tachometer_ppr:
#tachometer_poll_interval:
#enable_pin:
#   See the "fan" section for a description of the above parameters.
heater: extruder
#   Name of the config section defining the heater that this fan is
#   associated with. If a comma separated list of heater names is
#   provided here, then the fan will be enabled when any of the given
#   heaters are enabled. The default is "extruder".
heater_temp: 50.0
#   A temperature (in Celsius) that the heater must drop below before
#   the fan is disabled. The default is 50 Celsius.
fan_speed: 0.8
#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan
#   will be set to when its associated heater is enabled. The default
#   is 1.0

##################################################################################################################################################
##################################################################################################################################################

#[fan_generic cooling_fan_left] #**************************************************************************************************************************************************** out
#pin: PD12 #*********************************************************************************************************************************************************************** out
#max_power: 1.0 #******************************************************************************************************************************************************************* out

##################################################################################################################################################
##################################################################################################################################################

#[heater_fan fan3]
#pin: PD13

##################################################################################################################################################
##################################################################################################################################################

# Temperature-triggered cooling fans (one may define any number of 
#   sections with a "temperature_fan" prefix). A "temperature fan" is a 
#   fan that will be enabled whenever its associated sensor is above a 
#   set temperature. By default, a temperature_fan has a shutdown_speed 
#   equal to max_power.

#[heater_fan fan4]
#pin: PD14

#max_power:
#shutdown_speed:
#cycle_time:
#hardware_pwm:
#kick_start_time:
#off_below:
#tachometer_pin:
#tachometer_ppr:
#tachometer_poll_interval:
#enable_pin:
#   See the "fan" section for a description of the above parameters.
#sensor_type:
#sensor_pin:
#control:
#max_delta:
#min_temp:
#max_temp:
#   See the "extruder" section for a description of the above parameters.
#pid_Kp:
#pid_Ki:
#pid_Kd:
#   The proportional (pid_Kp), integral (pid_Ki), and derivative
#   (pid_Kd) settings for the PID feedback control system. Klipper
#   evaluates the PID settings with the following general formula:
#     fan_pwm = max_power - (Kp*e + Ki*integral(e) - Kd*derivative(e)) / 255
#   Where "e" is "target_temperature - measured_temperature" and
#   "fan_pwm" is the requested fan rate with 0.0 being full off and
#   1.0 being full on. The pid_Kp, pid_Ki, and pid_Kd parameters must
#   be provided when the PID control algorithm is enabled.
#pid_deriv_time: 2.0
#   A time value (in seconds) over which temperature measurements will
#   be smoothed when using the PID control algorithm. This may reduce
#   the impact of measurement noise. The default is 2 seconds.
#target_temp: 40.0
#   A temperature (in Celsius) that will be the target temperature.
#   The default is 40 degrees.
#max_speed: 1.0
#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan
#   will be set to when the sensor temperature exceeds the set value.
#   The default is 1.0.
#min_speed: 0.3
#   The minimum fan speed (expressed as a value from 0.0 to 1.0) that
#   the fan will be set to for PID temperature fans.
#   The default is 0.3.
#gcode_id:
#   If set, the temperature will be reported in M105 queries using the
#   given id. The default is to not report the temperature via M105.

##################################################################################################################################################
##################################################################################################################################################

# A "controller fan" is a fan that will be enabled whenever its 
#   associated heater or its associated stepper driver is active. The 
#   fan will stop whenever an idle_timeout is reached to ensure no 
#   overheating will occur after deactivating a watched component.

#[controller_fan fan5]
#pin: PD15
#max_power:
#shutdown_speed:
#cycle_time:
#hardware_pwm:
#kick_start_time:
#off_below:
#tachometer_pin:
#tachometer_ppr:
#tachometer_poll_interval:
#enable_pin:
#   See the "fan" section for a description of the above parameters.
#fan_speed: 1.0
#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan
#   will be set to when a heater or stepper driver is active.
#   The default is 1.0
#idle_timeout:
#   The amount of time (in seconds) after a stepper driver or heater
#   was active and the fan should be kept running. The default
#   is 30 seconds.
#idle_speed:
#   The fan speed (expressed as a value from 0.0 to 1.0) that the fan
#   will be set to when a heater or stepper driver was active and
#   before the idle_timeout is reached. The default is fan_speed.
#heater:
#stepper:
#   Name of the config section defining the heater/stepper that this fan
#   is associated with. If a comma separated list of heater/stepper names
#   is provided here, then the fan will be enabled when any of the given
#   heaters/steppers are enabled. The default heater is "extruder", the
#   default stepper is all of them.

##################################################################################################################################################
##################################################################################################################################################
################################################################### MCU ##########################################################################
##################################################################################################################################################
##################################################################################################################################################

[mcu]
serial: /dev/serial/by-id/usb-Klipper_stm32f446xx_46003D000451313031393839-if00
# CAN bus is also available on this board
#   The serial port to connect to the MCU. If unsure (or if it
#   changes) see the "Where's my serial port?" section of the FAQ.
#   This parameter must be provided when using a serial port.
#baud: 250000
#   The baud rate to use. The default is 250000.
#canbus_uuid:
#   If using a device connected to a CAN bus then this sets the unique
#   chip identifier to connect to. This value must be provided when using
#   CAN bus for communication.
#canbus_interface:
#   If using a device connected to a CAN bus then this sets the CAN
#   network interface to use. The default is 'can0'.
#restart_method:
#   This controls the mechanism the host will use to reset the
#   micro-controller. The choices are 'arduino', 'cheetah', 'rpi_usb',
#   and 'command'. The 'arduino' method (toggle DTR) is common on
#   Arduino boards and clones. The 'cheetah' method is a special
#   method needed for some Fysetc Cheetah boards. The 'rpi_usb' method
#   is useful on Raspberry Pi boards with micro-controllers powered
#   over USB - it briefly disables power to all USB ports to
#   accomplish a micro-controller reset. The 'command' method involves
#   sending a Klipper command to the micro-controller so that it can
#   reset itself. The default is 'arduino' if the micro-controller
#   communicates over a serial port, 'command' otherwise.

##################################################################################################################################################
##################################################################################################################################################
#################################################################### PRINTER #####################################################################
##################################################################################################################################################
##################################################################################################################################################

[printer]
kinematics: cartesian
#   kinematics:
#   The type of printer in use. This option may be one of: cartesian,
#   corexy, corexz, hybrid_corexy, hybrid_corexz, generic_cartesian,
#   rotary_delta, delta, deltesian, polar, winch, or none.
#   This parameter must be specified.
max_velocity: 300
#   max_velocity:
#   Maximum velocity (in mm/s) of the toolhead (relative to the
#   print). This value may be changed at runtime using the
#   SET_VELOCITY_LIMIT command. This parameter must be specified.
max_accel: 3000
#   max_accel:
#   Maximum acceleration (in mm/s^2) of the toolhead (relative to the
#   print). Although this parameter is described as a "maximum"
#   acceleration, in practice most moves that accelerate or decelerate
#   will do so at the rate specified here. The value specified here
#   may be changed at runtime using the SET_VELOCITY_LIMIT command.
#   This parameter must be specified.
max_z_velocity: 5
#   This sets the maximum velocity (in mm/s) of movement along the z
#   axis. This setting can be used to restrict the maximum speed of
#   the z stepper motor. The default is to use max_velocity for
#   max_z_velocity.
max_z_accel: 100
#   This sets the maximum acceleration (in mm/s^2) of movement along
#   the z axis. It limits the acceleration of the z stepper motor. The
#   default is to use max_accel for max_z_accel.

#minimum_cruise_ratio: 0.5
#   Most moves will accelerate to a cruising speed, travel at that
#   cruising speed, and then decelerate. However, some moves that
#   travel a short distance could nominally accelerate and then
#   immediately decelerate. This option reduces the top speed of these
#   moves to ensure there is always a minimum distance traveled at a
#   cruising speed. That is, it enforces a minimum distance traveled
#   at cruising speed relative to the total distance traveled. It is
#   intended to reduce the top speed of short zigzag moves (and thus
#   reduce printer vibration from these moves). For example, a
#   minimum_cruise_ratio of 0.5 would ensure that a standalone 1.5mm
#   move would have a minimum cruising distance of 0.75mm. Specify a
#   ratio of 0.0 to disable this feature (there would be no minimum
#   cruising distance enforced between acceleration and deceleration).
#   The value specified here may be changed at runtime using the
#   SET_VELOCITY_LIMIT command. The default is 0.5.
#square_corner_velocity: 5.0
#   The maximum velocity (in mm/s) that the toolhead may travel a 90
#   degree corner at. A non-zero value can reduce changes in extruder
#   flow rates by enabling instantaneous velocity changes of the
#   toolhead during cornering. This value configures the internal
#   centripetal velocity cornering algorithm; corners with angles
#   larger than 90 degrees will have a higher cornering velocity while
#   corners with angles less than 90 degrees will have a lower
#   cornering velocity. If this is set to zero then the toolhead will
#   decelerate to zero at each corner. The value specified here may be
#   changed at runtime using the SET_VELOCITY_LIMIT command. The
#   default is 5mm/s.

##################################################################################################################################################
##################################################################################################################################################
##################################################################### DISPLAY ####################################################################
##################################################################################################################################################
##################################################################################################################################################

# This section is used for a Creality "12864" display with a single
# ribbon cable between the display's EXP3 plug and the
# micro-controller board's EXP1 connector.

#[display]
#lcd_type: st7920
#cs_pin: EXP1_7  
#sclk_pin: EXP1_6  
#sid_pin: EXP1_8  
#encoder_pins: ^EXP1_5, ^EXP1_3 
#click_pin: ^!EXP1_2 

#[output_pin beeper]
#pin: EXP1_1

##################################################################################################################################################
##################################################################################################################################################

# Displays MCU and Pi temperatures on dashboard

[temperature_sensor MCU]
sensor_type: temperature_mcu
min_temp: 0
max_temp: 100

[temperature_sensor Pi]
sensor_type: temperature_host
min_temp: 0
max_temp: 80

##################################################################################################################################################
##################################################################################################################################################
################################################## TMC STEPPER DRIVER CONFIGURATION  #############################################################
##################################################################################################################################################
##################################################################################################################################################

##################################################################################################################################################
# TMC2209 configuration
##################################################################################################################################################

[tmc2209 stepper_x]
uart_pin: PC4
#   The pin connected to the TMC2208 PDN_UART line. This parameter
#   must be provided.
#tx_pin:
#   If using separate receive and transmit lines to communicate with
#   the driver then set uart_pin to the receive pin and tx_pin to the
#   transmit pin. The default is to use uart_pin for both reading and
#   writing.
#select_pins:
#   A comma separated list of pins to set prior to accessing the
#   tmc2209 UART. This may be useful for configuring an analog mux for
#   UART communication. The default is to not configure any pins.
#interpolate: True
#   If true, enable step interpolation (the driver will internally
#   step at a rate of 256 micro-steps). This interpolation does
#   introduce a small systemic positional deviation - see
#   TMC_Drivers.md for details. The default is True.
run_current: 0.800
#   The amount of current (in amps RMS) to configure the driver to use
#   during stepper movement. This parameter must be provided.
#hold_current:
#   The amount of current (in amps RMS) to configure the driver to use
#   when the stepper is not moving. Setting a hold_current is not
#   recommended (see TMC_Drivers.md for details). The default is to
#   not reduce the current.
#sense_resistor: 0.110
#   The resistance (in ohms) of the motor sense resistor. The default
#   is 0.110 ohms.
#diag_pin: PG6
#   The micro-controller pin attached to the DIAG line of the TMC2209
#   chip. The pin is normally prefaced with "^" to enable a pullup.
#   Setting this creates a "tmc2209_stepper_x:virtual_endstop" virtual
#   pin which may be used as the stepper's endstop_pin. Doing this
#   enables "sensorless homing". (Be sure to also set driver_SGTHRS to
#   an appropriate sensitivity value.) The default is to not enable
#   sensorless homing.
stealthchop_threshold: 999999
#   The velocity (in mm/s) to set the "stealthChop" threshold to. When
#   set, "stealthChop" mode will be enabled if the stepper motor
#   velocity is below this value. Note that the "sensorless homing"
#   code may temporarily override this setting during homing
#   operations. The default is 0, which disables "stealthChop" mode.
#coolstep_threshold:
#   The velocity (in mm/s) to set the TMC driver internal "CoolStep"
#   threshold to. If set, the coolstep feature will be enabled when
#   the stepper motor velocity is near or above this value. Important
#   - if coolstep_threshold is set and "sensorless homing" is used,
#   then one must ensure that the homing speed is above the coolstep
#   threshold! The default is to not enable the coolstep feature.
#uart_address:
#   The address of the TMC2209 chip for UART messages (an integer
#   between 0 and 3). This is typically used when multiple TMC2209
#   chips are connected to the same UART pin. The default is zero.
#driver_MULTISTEP_FILT: True
#driver_IHOLDDELAY: 8
#driver_TPOWERDOWN: 20
#driver_TBL: 2
#driver_TOFF: 3
#driver_HEND: 0
#driver_HSTRT: 5
#driver_PWM_AUTOGRAD: True
#driver_PWM_AUTOSCALE: True
#driver_PWM_LIM: 12
#driver_PWM_REG: 8
#driver_PWM_FREQ: 1
#driver_PWM_GRAD: 14
#driver_PWM_OFS: 36
#driver_FREEWHEEL: 0
#driver_SGTHRS: 0
#driver_SEMIN: 0
#driver_SEUP: 0
#driver_SEMAX: 0
#driver_SEDN: 0
#driver_SEIMIN: 0
#   Set the given register during the configuration of the TMC2209
#   chip. This may be used to set custom motor parameters. The
#   defaults for each parameter are next to the parameter name in the
#   above list.

##################################################################################################################################################

[tmc2209 stepper_y]
uart_pin: PD11
#diag_pin: PG9
run_current: 0.800
stealthchop_threshold: 999999

##################################################################################################################################################

[tmc2209 stepper_z]
uart_pin: PC6
##diag_pin: PG10
run_current: 0.650
stealthchop_threshold: 999999

##################################################################################################################################################

#[tmc2209 stepper_]
#uart_pin: PC7
##diag_pin: PG11
#run_current: 0.650
#stealthchop_threshold: 999999

[tmc2209 stepper_z1]
uart_pin: PC7
##diag_pin: PG10
run_current: 0.650
stealthchop_threshold: 999999

##################################################################################################################################################

[tmc2209 extruder]
uart_pin: PF2
run_current: 0.600
stealthchop_threshold: 999999

##################################################################################################################################################

#[tmc2209 extruder1]
#uart_pin: PE4
#run_current: 0.800
#stealthchop_threshold: 999999

##################################################################################################################################################

#[tmc2209 extruder2]
#uart_pin: PE1
#run_current: 0.800
#stealthchop_threshold: 999999

##################################################################################################################################################

#[tmc2209 extruder3]
#uart_pin: PD3
#run_current: 0.800
#stealthchop_threshold: 999999

##################################################################################################################################################
##################################################################################################################################################
############################################################# BOARD PINS #########################################################################
##################################################################################################################################################
##################################################################################################################################################

[board_pins]
aliases:
    # EXP1 header
    EXP1_1=PE8, EXP1_2=PE7,
    EXP1_3=PE9, EXP1_4=PE10,
    EXP1_5=PE12, EXP1_6=PE13,    # Slot in the socket on this side
    EXP1_7=PE14, EXP1_8=PE15,
    EXP1_9=<GND>, EXP1_10=<5V>,

    # EXP2 header
    EXP2_1=PA6, EXP2_2=PA5,
    EXP2_3=PB1, EXP2_4=PA4,
    EXP2_5=PB2, EXP2_6=PA7,      # Slot in the socket on this side
    EXP2_7=PC15, EXP2_8=<RST>,
    EXP2_9=<GND>, EXP2_10=PC5



#[neopixel my_neopixel]
#pin: PB0


##################################################################################################################################################
##################################################################################################################################################
################################################################ FURTHER SETTINGS ################################################################
##################################################################################################################################################
##################################################################################################################################################

# For Tram Z
[force_move]
enable_force_move: TRUE


##################################################################################################################################################    
##################################################################################################################################################
######################################################### KlackEnder- Settings ###################################################################
##################################################################################################################################################
##################################################################################################################################################

# !! Change your Z endstop pin from 'endstop_pin: Pin123' to 'endstop_pin: probe:z_virtual_endstop'
# !! Also add in [stepper_y] 'position_min: -8'. Idk why but most configs have this wrong. For the Stock Ender 3 the homed Y position is -8.

[probe]
pin: ^PG10 #Change to where you plug your probe in, endstop or probe pin pulled high (^)
z_offset: 7 #Measure per your specific setup. Klipper will NOT save this value if this in not located in printer.cfg
x_offset: 3 # negative = left of the nozzle
y_offset: 26 # negative = in front of of the nozzle
speed: 5.0
lift_speed: 15.0
sample_retract_dist: 1
samples: 2
samples_tolerance_retries: 6

##[(7x7)-1] / 2 = 24
##[(5x5)-1] / 2 = 12

##################################################################################################################################################

[bed_mesh]
speed: 300
horizontal_move_z: 14 #Positive value equal to z_offset or larger. eg: if z_offset is -2.5 this must be at least 2.5 or larger
mesh_min: 8,30
mesh_max: 223,201
probe_count: 5,5
zero_reference_position: 117.5, 117.5 #for 235x235 bed. adapt to your bed size if needed. same for mesh min and max above
algorithm: bicubic
fade_start: 1
fade_end: 10
#fade_target:
#   The z position in which fade should converge. When this value is set
#   to a non-zero value it must be within the range of z-values in the mesh.
#   Users that wish to converge to the z homing position should set this to 0.
#   Default is the average z value of the mesh.
split_delta_z: 0.015
#   The amount of Z difference (in mm) along a move that will
#   trigger a split. Default is .025.
move_check_distance: 3
#   The distance (in mm) along a move to check for split_delta_z.
#   This is also the minimum length that a move can be split. Default
#   is 5.0.
mesh_pps: 4,4
#   A comma separated pair of integers (X,Y) defining the number of
#   points per segment to interpolate in the mesh along each axis. A
#   "segment" can be defined as the space between each probed
#   point. The user may enter a single value which will be applied
#   to both axes.  Default is 2,2.
#bicubic_tension: .2
#   When using the bicubic algorithm the tension parameter above
#   may be applied to change the amount of slope interpolated.
#   Larger numbers will increase the amount of slope, which
#   results in more curvature in the mesh. Default is .2.
#adaptive_margin:
#   An optional margin (in mm) to be added around the bed area used by
#   the defined print objects when generating an adaptive mesh.

##################################################################################################################################################

[homing_override]
set_position_z:0 # Make printer think Z axis is at zero, so we can force a move upwards away from build plate
axes: z #will only call override if x is involved in the homing call
gcode:
    G90
    G1 Z10 F3000 ; move up to prevent accidentally scratching build plate    
    {% if "x" not in (printer.toolhead.homed_axes | lower) %}
        G28 X
    {% endif %}
    {% if "y" not in (printer.toolhead.homed_axes | lower) %}
        G28 Y        #Will only home XY if they are not currently homed
    {% endif %}
    #PROBE_OUT
    G1 X181 Y242 F6000 ; Adjusted for normal klack offsets with a 235x235 bed X: 117.5 - x_offset, Y: 117.5 - y_offset
    G28 Z
    G1 Z6 F3000
    G1 X0 Y0 F6000
    #PROBE_IN

##################################################################################################################################################

[screws_tilt_adjust] #Change to your specific printer is needed. Back left screw as referance point and that's where strain relief is is recommended
screw1: 28.5, 171.5
screw1_name: Back left
screw2: 28.5, 11.5
screw2_name: Front left
screw3: 198.5, 11.5
screw3_name: Front right
screw4: 198.5, 181.5
screw4_name: Back right
screw_thread: CW-M4 #Ender 3s use CW-M4 change for your printer if needed
horizontal_move_z: 10
# To calculate the position of your screws:
# Screw Offsets: 32.5mm for ender 3 beds
# Default Klack probe offsets: X: 4, Y: 21
#Back left	
#   X: 0 + screw_x_offset - probe.x_offset	
#   Y: 235 - screw_y_offset - probe.y_offset
#Front left	
#   X: 0 + screw_x_offset - probe.x_offset	
#   Y: 0 + screw_y_offset - probe.y_offset
#Front right 
#   X: 235 - screw_x_offset - probe.x_offset	
#   Y: 0 + screw_y_offset - probe.y_offset
#Back right	
#   X: 235 - screw_x_offset - probe.x_offset	
#   Y: 235 - screw_y_offset - probe.y_offset
# x and y offsets are usually the same. You will have to find info on your printer or measure them yourself
# This can be adapted for three screw bed as well without eny problem. In that case X offset of the third screw would be build volume divided by 2

##################################################################################################################################################

[gcode_macro SCREWS_TILT_CALCULATE]
rename_existing: _SCREWS_TILT_CALCULATE
gcode:
    _CONDITIONAL_HOME ; Should always home before calculation even if already homed
    probe_out
    _SCREWS_TILT_CALCULATE
    probe_in

##################################################################################################################################################
##################################################################################################################################################
######################################################## KlackEnder- Macros ######################################################################
##################################################################################################################################################
##################################################################################################################################################

[gcode_macro PROBE_OUT]
gcode:
    G90
    G1 X242 F4000
    G4 P25
    G1 Z15
    G1 X220

##################################################################################################################################################

[gcode_macro PROBE_IN]
gcode:
    G90
    G1 Z20
    G1 X245 F6000
    G1 Y0 ; Check this against your config of [stepper_y] position_min: ...!
    G1 Z0
    G4 P300
    G1 X235 F6000
    G1 Z10
    G1 X220

##################################################################################################################################################

[gcode_macro BED_MESH_CALIBRATE] #macro with parameter passing
rename_existing: _BED_MESH_CALIBRATE
gcode:
    #PROBE_OUT
    _BED_MESH_CALIBRATE {rawparams}
    #PROBE_IN

##################################################################################################################################################

[gcode_macro PROBE_CALIBRATE]
rename_existing: _PROBE_CALIBRATE
gcode:
    {% if not 'xyz' in printer.toolhead.homed_axes %}
    G28
    {% endif %}
    PROBE_OUT
    G90
    G1 Z20
    G1 X113.5 Y96.5 F12000 ; Readjust for center of bed adjusted for probe offset
    _PROBE_CALIBRATE
    TESTZ Z=20
    M117 Remove the Klack to continue calibration!

##################################################################################################################################################

[gcode_macro PROBE_ACCURACY]
rename_existing: _PROBE_ACCURACY
gcode:
    {% if not 'xyz' in printer.toolhead.homed_axes %}
    G28
    {% endif %}
    PROBE_OUT
    G90
    G1 X113.5 Y96.5 F12000 ; Readjust for center of bed adjusted for probe offset
    _PROBE_ACCURACY
    PROBE_IN

##################################################################################################################################################

[gcode_macro Z_TILT_ADJUST] #Uncomment this macro if using dual z with z_tilt
rename_existing: _Z_TILT_ADJUST
gcode:
    #PROBE_OUT
    _Z_TILT_ADJUST

##################################################################################################################################################
##################################################################################################################################################
############################################################# CALIBRATE Z ########################################################################
##################################################################################################################################################
##################################################################################################################################################

[z_calibration]
nozzle_xy_position: 181,242 #<X,Y position for clicking the nozzle on the z endstop - not needed if [safe_z_home] is used>
switch_xy_position: 170,215   #<X,Y offsets from the nozzle position for clicking the probe's switch body on the z endstop>
bed_xy_position: 117.5,117.5     #<X,Y position for probing the bed, for instance the center point - not needed if mesh with zero_reference_position is used>
switch_offset: 0.5       #<offset of the switch trigger (read the Switch Offset section!)>
#start_gcode: PROBE_OUT         #<macro name for attaching the probe> or use bursh macro *************************************************************************************************** out
#start_gcode: KOMB #************************************************************************************************************************************************************************************ in
#before_switch_gcode: PROBE_OUT #<macro name for attaching the probe AFTER probing the nozzle> ********************************************************************************************* in
#end_gcode: PROBE_IN            #<macro name for docking the probe> &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
safe_z_height: 14
speed: 50
offset_margins: -1.0,1.0
#   The minimum and maximum margins allowed for the calculated offset.
#   If the offset is outside these values, it will stop!
#   The margin can be defined as "min,max" e.g. "-0.5,1.5" or by just one
#   value e.g. "1.0" which translates to "-1.0,1.0" (which is also the default).

##################################################################################################################################################

[gcode_macro CALIBRATE_Z]
rename_existing: BASE_CALIBRATE_Z
gcode:
    {% set nozzle_position = params.NOZZLE_POSITION %}
    {% set switch_position = params.SWITCH_POSITION %}
    {% set bed_position = params.BED_POSITION %}
    {% set switch_offset = params.SWITCH_OFFSET %}
    _CONDITIONAL_HOME                         # can also be a conditional homing macro *********************************************************************************************** G28 to conditional
    #PROBE_OUT                # a macro for fetching the probe first ***************************************************************************************************************** out
    BASE_CALIBRATE_Z NOZZLE_POSITION={nozzle_position} SWITCH_POSITION={switch_position} BED_POSITION={bed_position} SWITCH_OFFSET={switch_offset}
    #PROBE_IN                # and parking it afterwards (or DOCK_PROBE in klicky macros) &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& out 

##################################################################################################################################################

[gcode_macro Z_CALIBRATION]
gcode:
      CALIBRATE_Z


##################################################################################################################################################

# Replace M109 (wait for hotend temperature) and M190 (wait for bed temperature) with TEMPERATURE_WAIT.
# This just makes Klipper resume immediately after reaching temp. Otherwise it waits for the temperature to stabilize.

[gcode_macro M109]
rename_existing: M99109
gcode:
    #Parameters
    {% set s = params.S|float %}
    
    M104 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}  ; Set hotend temp
    {% if s != 0 %}
        TEMPERATURE_WAIT SENSOR=extruder MINIMUM={s} MAXIMUM={s+1}   ; Wait for hotend temp (within 1 degree)
    {% endif %}

[gcode_macro M190]
rename_existing: M99190
gcode:
    #Parameters
    {% set s = params.S|float %}

    M140 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}   ; Set bed temp
    {% if s != 0 %}
        TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={s} MAXIMUM={s+1}  ; Wait for bed temp (within 1 degree)
    {% endif %}

##################################################################################################################################################
##################################################################################################################################################
##################################################################### KOMB #######################################################################
##################################################################################################################################################
##################################################################################################################################################

[include _KOMB_Variables.cfg]

[gcode_macro KOMB]
gcode:
    SAVE_GCODE_STATE NAME=clean_nozzle_state

    ## Define color-wrapper
    {% set ns2 = namespace() %}
    {% macro color_text(text='', color='primary') -%}
        {% set color = color | string %}
        {% set text = text | string  %}
        {% set ns2.out = '<span class=' + color + '--text>' + text + '</span>'| string %}
    {% endmacro %}

    # Welcome message
    { color_text(color="primary", text="K") }
    {% set msg = ns2.out %}
    { color_text(color="error", text="O") }
    {% set msg = msg + ns2.out %}
    { color_text(color="warning", text="M") }
    {% set msg = msg + ns2.out %}
    { color_text(color="accent", text="B") }
    {% set msg = msg + ns2.out %}
    { color_text(color="success", text="ing") }
    {% set msg = msg + ns2.out %}
    { color_text(color="primary", text=" Started") }
    {% set msg = msg + ns2.out %}
    { color_text(color="secondary", text="!") }
    {% set msg = msg + ns2.out %}
    { action_respond_info( msg ) }

    {% set vars = printer["gcode_macro _KOMB_Variables"] %}

    {% set x_min = params.BRUSH_LOCATION_X|default(vars.brush_location_x)|float %}
    {% set size_x = params.BRUSH_SIZE_X|default(vars.brush_size_x)|float %}    
    {% set offset = params.OFFSET|default(vars.offset)|float %}
    {% set repeat = params.REPEAT|default(vars.repeat)|int %}
    {% set y_min = params.BRUSH_LOCATION_Y|default(vars.brush_location_y)|float %}
    {% set size_y = params.BRUSH_SIZE_Y|default(vars.brush_size_y)|float %}
    {% set step = params.STEP_SIZE|default(vars.step)|float %}
    {% set reverse = params.ENABLE_REVERSE|default(vars.reverse_enable)|abs %}
    {% set z_max = params.BRUSH_LOCATION_Z|default(vars.brush_location_z)|float %}
    {% set size_z = params.BRUSH_SIZE_Z|default(vars.brush_size_z)|float %}
    {% set z_step = params.Z_STEP_SIZE|default(vars.z_step)|float %}
    {% set z_hop_height = params.Z_HOP_HEIGHT|default(vars.z_hop_height)|float %}
    {% set speed = params.SPEED|default(vars.speed)|int %}
    {% set retract_before = params.RETRACT_BEFORE_WIPE|default(vars.retract_before_wipe)|float %}
    {% set auto_home = params.ENABLE_AUTO_HOMING|default(vars.auto_home_enable)|abs %}
    {% set opposite_side = params.START_OPPOSITE_SIDE|default(vars.start_opposite_side)|abs %}
    {% set speed_up = params.SPEED_UP_BY|default(vars.speed_up)|int %}
    {% set retract_during = params.RETRACT_DURING_WIPE|default(vars.retract_during_wipe)|float %}
    {% set auto_heat = params.AUTO_HEAT_NOZZLE|default(vars.auto_heat_nozzle) | abs %}
    {% set adjacent_side = params.START_ADJACENT_SIDE|default(vars.start_adjacent_side)|abs %}
    {% set travel_speed = params.TRAVEL_SPEED|default(vars.travel_speed)|int %}
    {% set retract_after = params.RETRACT_AFTER_WIPE|default(vars.retract_after_wipe)|float %}
    {% set cold_clean = params.CLEAN_WHILE_COLD|default(vars.clean_while_cold)|abs %}
    {% set pattern = params.PATTERN|default(vars.pattern) %}
    {% set verbose = params.ENABLE_VERBOSE_OUTPUT|default(vars.verbose_enable)|abs %}
    {% set verbose_points = params.ENABLE_VERBOSE_POINTS|default(vars.verbose_points)|abs %}
    {% set temp = params.TEMPERATURE|default(vars.temp) %}
    {% set angle = params.ANGLE|default(vars.angle) %}
    {% set return_to_start = params.ENABLE_RETURN_TO_START|default(vars.return_to_start)|abs %}
    {% set purge = params.PURGE_AMOUNT|default(vars.purge_amount)|float %}
    {% set purge_x = params.PURGE_LOCATION_X|default(vars.purge_location_x)|float %}
    {% set purge_y = params.PURGE_LOCATION_Y|default(vars.purge_location_y)|float %}
    {% set purge_z = params.PURGE_LOCATION_Z|default(vars.purge_location_z)|float %}
    {% set current_x = printer.toolhead.position.x %}
    {% set current_y = printer.toolhead.position.y %}
    {% set current_z = printer.toolhead.position.z %}

    # verbose|lower = "true" Output: Print calculated center values
    {% if verbose_points %}
        { action_respond_info("Starting Position: ({}, {}, {})".format(
            (current_x),
            (current_y),
            (current_z),
        )) }
    {% endif %}

    #Set Y or X brush size to current location if size and location set to 0
    {% if y_min == 0 %} 
        {% set y_min = printer.toolhead.position.y %}
    {% elif x_min == 0 %} 
        {% set x_min = printer.toolhead.position.y %}
    {% endif %}   
    {% if z_max == 0 %} 
        {% set z_max = printer.toolhead.position.z %}
    {% endif %}

    {% set x_max, y_max, z_min = x_min + size_x, y_min + size_y, z_max - size_z | float %}

    # Verbose Output: Print all axis min/max and z_hop height
    {% if verbose %}
        { action_respond_info("Brush Location: [Min: ({},{},{}), Max: ({},{},{})]. z_hop {}".format(
            (x_min), 
            (y_min),
            (z_min),
            (x_max), 
            (y_max),
            (z_max),
            (z_hop_height), 
        )) }
    {% endif %}

    # verbose|lower = "true" Output: Print calculated center values
    {% if verbose %}
        { action_respond_info("Brush size: {}mm x {}mm x {}mm".format(
            (size_x),
            (size_y),
            (size_z),
        )) }
    {% endif %}

    #Recalcualte min/max with offset
    {% set x_min, y_min = x_min - offset, y_min - offset | float %} 
    {% set x_max, y_max = x_max + offset, y_max + offset | float %} 
    {% set z_hop = z_max + z_hop_height | float %}

    # Verbose Output: Print axis min/max and z_hop adjusted for offsets
    {% if verbose %}
        { action_respond_info("Values adjusted for offsets [Min: ({},{},{}), Max: ({},{},{})], Z_Hop_Height: {}".format(
            (x_min), 
            (y_min),
            (z_min),
            (x_max), 
            (y_max),
            (z_max),
            (z_hop),
        )) }
    {% endif %}

    # Check if min/max exceed configured limits and correct to avoid errors.
    {% set x_min = x_min if x_min <= printer.toolhead.axis_maximum.x or x_min >= printer.toolhead.axis_minimum.x else printer.toolhead.axis_minimum.x %}
    {% set x_max = x_max if x_max >= printer.toolhead.axis_minimum.x or x_max <= printer.toolhead.axis_minimum.x else printer.toolhead.axis_maximum.x %}
    {% set y_min = y_min if y_min >= printer.toolhead.axis_minimum.y or y_min <= printer.toolhead.axis_minimum.y else printer.toolhead.axis_minimum.y %}
    {% set y_max = y_max if y_max <= printer.toolhead.axis_maximum.y or y_max >= printer.toolhead.axis_minimum.y else printer.toolhead.axis_maximum.y %}   
    {% set z_min = z_min if z_min >= printer.toolhead.axis_minimum.z or z_min <= printer.toolhead.axis_minimum.z else printer.toolhead.axis_minimum.z %}
    {% set z_max = z_max if z_max <= printer.toolhead.axis_maximum.z or z_max >= printer.toolhead.axis_maximum.z else printer.toolhead.axis_maximum.z %}
    {% set z_hop = z_hop if z_hop >= printer.toolhead.axis_minimum.z or z_hop <= printer.toolhead.axis_maximum.z else z_max %}

    {% set y_min = printer.toolhead.position.y if size_y == 0 and y_min == 0 else y_min %}
    {% set y_max = printer.toolhead.position.y if size_y == 0 and y_max == 0 else y_max %}
    {% set z_min = printer.toolhead.position.z if size_z == 0 and z_min == 0 else z_min %}
    {% set z_max = printer.toolhead.position.z if size_z == 0 and z_max == 0 else z_max %}

    # Verbose Output: Print adjusted axis min, max values
    {% if verbose %}
        { action_respond_info("Values adjusted for axis limits: [Min: ({},{},{}), Max: ({},{},{})]. Z_Hop Height: {}".format(
            (x_min), 
            (y_min),
            (z_min),
            (x_max), 
            (y_max),
            (z_max),
            (z_hop), 
        )) }
    {% endif %}

    #Adjust brush size based on recalculated min/max values
    {% set size_x = x_max - x_min | round(1) %}
    {% set size_y = y_max - y_min | round(1) %}
    {% set size_z = z_max - z_min | round(1) %}  

    # Verbose Output: Print calculated center values
    {% if verbose %}
        { action_respond_info("Adjusted brush size: {}mm x {}mm x {}mm".format(
            (size_x),
            (size_y),
            (size_z),
        )) }
    {% endif %}

    #Set X brush size to current location if size set to 0
    {% if x_min == 0 and size_x == 1 %} 
        {% set x_min = printer.toolhead.position.x %}
        {% set x_max = printer.toolhead.position.x %}
        # Verbose Output: Print calculated adjusted values
        {% if verbose %}
            { action_respond_info("Adjusted X to Min: {}, Max: {}, Brush_Size: {}".format(
                (x_min),
                (x_max),
                (size_x),
            )) }
        {% endif %}
    #Set Y brush size to current location if size set to 0
    {% elif y_min == 0 and size_y == 1 %} 
        {% set y_min = printer.toolhead.position.y %}
        {% set y_max = printer.toolhead.position.y %}
        # Verbose Output: Print calculated adjusted values
        {% if verbose %}
            { action_respond_info("Adjusted Y to Min: {}, Max: {}, Brush_Size: {}".format(
                (y_min),
                (y_max),
                (size_y),
            )) }
        {% endif %}
    {% endif %}

    {% set x_center, y_center, z_center = (x_min + x_max) / 2, (y_min + y_max) / 2, (z_min + z_max) / 2 | round(1) %}

    # Verbose Output: Print calculated center values
    {% if verbose %}
        { action_respond_info("Center: X:{}, Y:{}, Z:{}".format(
            (x_center),
            (y_center),
            (z_center),
        )) }
    {% endif %}

    # Calculate aspect ratio
    {% set long_side = (size_x, size_y) | max %}
    {% set short_side = (size_x, size_y) | min if size_y != 0 or size_x != 0 else 1 %}
    {% set aspect_ratio = (long_side / short_side) | round(1) if short_side != 0 else long_side / 1 %}

    {% set long_center = (x_max + x_min) / 2 if long_side == size_x else (y_max + y_min) / 2 %}
    {% set short_center = (y_max + y_min) / 2 if short_side == size_y else (x_max + x_min) / 2 %}

    # Verbose Output
    {% if verbose %}
        { action_respond_info("Longer_Side: {}mm, Shorter_Side: {}mm, Aspect_Ratio: {}:{} ({})\nLong_Center: {}, Short_Center: {}".format(
            (long_side),
            (short_side),
            (long_side),
            (short_side),
            (aspect_ratio),
            (long_center),
            (short_center),
        )) }
    {% endif %}

    # Taylor series approximations for sin and cos for performing diagonal movement calculations 
    {% set angle_rad = angle | float * 3.141592653589793 / 180.0 | float | round(5) %}
    {% set sin_angle = (angle_rad - (angle_rad**3)/6 + (angle_rad**5)/120|float) if angle != 45 else 1 %}
    {% set cos_angle = (1 - (angle_rad**2)/2 + (angle_rad**4)/24|float) if angle != 45 else 1 %} 

    # Verbose Output: Print values to use for diagonal calculations
    {% if verbose %}
        { action_respond_info("Angle_Radians: {}, Sin_Angle: {}, Cos_Angle: {}".format(
            (angle_rad),
            (sin_angle),
            (cos_angle),
        )) }
    {% endif %}

    {% if pattern == 1 %}    
        # Verbose Output: Print pattern #
        {% if verbose %}
            { action_respond_info("Pattern {}".format(
                (pattern),
            )) }
        {% endif %} 

        {% set r_val = retract_before if printer.extruder.temperature >= temp else 0 %}
        # Verbose Output: Print retraction values
        {% if verbose %}
            { action_respond_info("Retraction: Before_Wipe: {}, During_Wipe: {}, After-Wipe: {}".format(
                (retract_before * -1),
                (retract_during * -1),
                (retract_after * -1),
            )) }
        {% endif %}

        {% set points = [] %}
        {% set i_val = 0 %}
        {% set j_val = 0 %}
        {% set f_val = speed %}

        # Verbose Output
        {% if verbose %}
            { action_respond_info("I_Val: {}, J_val: {}, R_Val: {}, F_Val: {}".format(
                (i_val),
                (j_val),
                (r_val),
                (f_val),
            )) }
        {% endif %}

        {% set ns = namespace() %}
        {% set ns.nozzle_pos = [x_min, y_min, z_max, i_val, j_val, r_val, f_val] if not opposite_side else [x_max, y_max, z_max, i_val, j_val, r_val, f_val] %}
        {% set nozzle_pos = ns.nozzle_pos %}
        {% set start_pos = ns.nozzle_pos %}
        {% set _ = points.append(ns.nozzle_pos) %}
             
        # Calculate the number of steps in all directions 
        {% set long_points = ((long_side / step) | round) if size_y != 0 else 1 %}
        {% set short_points = short_side / step | round if size_y != 0 or size_x != 0 else 1 %}

        # Verbose Output: Print points and position
        {% if verbose %}
            { action_respond_info("Long_Points: {}, Short_Points: {}\nNozzle_Position: {}".format(
                (long_points),
                (short_points),
                (nozzle_pos),
            )) }
        {% endif %}      

        {% if verbose_points %}
            { action_respond_info("Starting Position: {}".format(
                (start_pos),
            )) }
        {% endif %}  

        {% for r in range(1 + repeat|int) %} 
            {% set tmp_points = [] %}
            {% for i in range(long_points|int) %}
                # Generate 1st point
                {% if not adjacent_side %}
                    {% if not opposite_side %} 
                        {% set x_val = nozzle_pos[0] + size_y + i | round(1) if size_y != 0 else nozzle_pos[0] + size_x | round(1) %}
                        {% set y_val = nozzle_pos[1] + size_y if size_y != 0 else nozzle_pos[1] %}
                    {% else %} # If opposite_side = true and adjacent side = false
                        {% set x_val = nozzle_pos[0] - size_y - i | round(1) if size_y != 0 else nozzle_pos[0] - size_x | round(1) %}
                        {% set y_val = nozzle_pos[1] - size_y if size_y != 0 else nozzle_pos[1] %}%}
                    {% endif %}
                {% else %} # if adjacent side = true
                    {% if not opposite_side %}
                        {% set x_val = nozzle_pos[0] + size_x if size_x != 0 else nozzle_pos[0] %}
                        {% set y_val = nozzle_pos[1] + size_x + i | round(1) if size_x != 0 else nozzle_pos[0] + size_y | round(1) %}
                    {% else %} # If opposite_side = true 
                        {% set x_val = nozzle_pos[0] - size_x if size_x != 0 else nozzle_pos[0] %}%}
                        {% set y_val = nozzle_pos[1] - size_x - i | round(1) if size_x != 0 else nozzle_pos[0] - size_y | round(1) %}
                    {% endif %}
                {% endif %}
                {% set z_val = ns.nozzle_pos[2] if nozzle_pos[2] != 0 else printer.toolhead.position.z %} 
                {% set r_val = 0 %}
                {% set f_val = ns.nozzle_pos[6] %}
                {% set nozzle_pos = [x_val, y_val, z_val, i_val, j_val, r_val, f_val] %}
                {% set _ = tmp_points.append(nozzle_pos) %}
                # Generate 2nd point
                {% if not adjacent_side %}
                    {% if not opposite_side %}
                        {% set x_val2 = start_pos[0] + (step * cos_angle) + i | round(1) if size_y != 0 else start_pos[0] %}
                        {% set y_val2 = start_pos[1] if angle != 0 else start_pos[1] + step + i %}
                    {% else %} 
                        {% set x_val2 = start_pos[0] - (step * cos_angle) - i | round(1) if size_y != 0 else start_pos[0] %}
                        {% set y_val2 = start_pos[1] if angle != 0 else start_pos[1] - step - i %}   
                    {% endif %}
                {% else %} 
                    {% if not opposite_side %}
                        {% set x_val2 = start_pos[0] if angle != 0 else start_pos[0] + step + i %}
                        {% set y_val2 = start_pos[1] + (step * sin_angle) + i | round(1) if size_x != 0 else start_pos[1] %}   
                    {% else %} 
                        {% set x_val2 = start_pos[0] if angle != 0 else start_pos[0] - step - i %}
                        {% set y_val2 = start_pos[1] - (step * sin_angle) - i | round(1) if size_x != 0 else start_pos[1] %}      
                    {% endif %}
                {% endif %}
                {% set nozzle_pos2 = [x_val2, y_val2, z_val, i_val, j_val, r_val, f_val] %}
                {% set _ = tmp_points.append(nozzle_pos2) %}
            {% endfor %}
        
            {% if reverse %}
                {% set nozzle_rev = tmp_points[:] %}
                {% set _ = nozzle_rev.reverse() %}
                {% set _ = tmp_points.extend(nozzle_rev) %}
            {% endif %}

            {% set z_val = (ns.nozzle_pos[2] - z_step) if ns.nozzle_pos[2] - z_step >= z_min else start_pos[2] %}
            {% set r_val = retract_during if printer.extruder.temperature >= temp else 0 %}
            {% set f_val = nozzle_pos[6] + speed_up + r %}
            {% set ns.nozzle_pos = [nozzle_pos[0], nozzle_pos[1], z_val, i_val, j_val, r_val, f_val] %}
            {% set _ = tmp_points.append(ns.nozzle_pos) %}        
            {% set _ = points.extend(tmp_points) %}
        {% endfor %}

    {% elif pattern == 2 %}    
        # Verbose Output: Print pattern #
        {% if verbose %}
            { action_respond_info("Pattern {}".format(
                (pattern),
            )) }
        {% endif %} 
        
        {% set r_val = retract_before if printer.extruder.temperature >= temp else 0 %}
        # Verbose Output: Print retraction values
        {% if verbose %}
            { action_respond_info("Retraction: Before_Wipe: {}, During_Wipe: {}, After-Wipe: {}".format(
                (retract_before * -1),
                (retract_during * -1),
                (retract_after * -1),
            )) }
        {% endif %}

        # Calculate the diameter of the brush
        {% set diameter = (size_x, size_y) | min %}
        {% set radius = diameter / 2 %}
        {% set x_min, x_max = (x_min + radius) - step, (x_max - radius) + step %} 

        # Verbose Output:
        {% if verbose %}
           { action_respond_info("Diameter: {}, Radius: {}\nX_Min: {}, X_Max: {}".format(
                (diameter),
                (radius),
                (x_min),
                (x_max),
            )) }
        {% endif %}

        {% set i_val = radius if adjacent_side else 0 %}
        {% set j_val = 0 if adjacent_side else radius %}
        {% set f_val = speed %}

        {% if verbose %}
            { action_respond_info("I_Val: {}, J_val: {}, R_Val: {}, F_Val: {}".format(
                (i_val),
                (j_val),
                (r_val),
                (f_val),
            )) }
        {% endif %}

        # Calculate the number of steps in all directions 
        {% set long_points = (x_max - x_min) / step | round(1) if long_side == size_x else (y_max - y_min) / step | round(1) %}
        {% set short_points = (y_max - y_min) / step | round(1) if short_side == size_y else (x_max - x_min) / step | round(1) %}

        # Verbose Output: Print points
        {% if verbose %}
            { action_respond_info("Long_Points: {}, Short_Points: {}".format(
                (long_points),
                (short_points),
            )) }
        {% endif %}      

        {% set ns = namespace() %}
        {% set ns.nozzle_pos = [x_min, y_min, z_max, i_val, j_val, r_val, f_val] if not opposite_side else [x_max, y_min, z_max, i_val, j_val, r_val, f_val] %}
        {% set nozzle_pos, start_pos = ns.nozzle_pos, ns.nozzle_pos %}
        {% set points = [] %}
        {% set _ = points.append(ns.nozzle_pos) %}

        # Verbose Output: Print points and position
        {% if verbose %}
            { action_respond_info("Nozzle_Position: {}".format(
                (nozzle_pos),
            )) }
        {% endif %}      

        {% if verbose_points %}
            { action_respond_info("Starting Position: {}".format(
                (start_pos),
            )) }
        {% endif %}  
        
        {% for r in range(1 + repeat|int) %} 
            {% set tmp_points = [] %}
            {% for i in range(long_points|int) %}        
                {% if not opposite_side %} 
                    {% set x_val = nozzle_pos[0] + step + i if not adjacent_side else nozzle_pos[0] %}
                    {% set y_val = nozzle_pos[1] if not adjacent_side else nozzle_pos[0] + step + i %}
                    {% set i_val = 0 if not adjacent_side else radius %}
                    {% set j_val = radius if not adjacent_side else 0 %}
                {% else %} 
                    {% set x_val = nozzle_pos[0] - step - i if not adjacent_side else nozzle_pos[0] %}
                    {% set y_val = nozzle_pos[1] if not adjacent_side else nozzle_pos[0] - step - i %}
                    {% set i_val = 0 if not adjacent_side else -radius %}
                    {% set j_val = -radius if not adjacent_side else 0 %}
                {% endif %}  
                {% set z_val = ns.nozzle_pos[2] if nozzle_pos[2] != 0 else printer.toolhead.position.z %} 
                {% set r_val = 0 %}
                {% set f_val = nozzle_pos[6] %}
                {% set nozzle_pos = [x_val, y_val, z_val, i_val, j_val, r_val, f_val] %}
                {% set _ = tmp_points.append(nozzle_pos) %}
            {% endfor %}

            {% if reverse %}
                {% set nozzle_rev = tmp_points[:] %}
                {% set _ = nozzle_rev.reverse() %}
                {% set _ = tmp_points.extend(nozzle_rev) %}
            {% endif %}

            {% set z_val = (ns.nozzle_pos[2] - z_step) if ns.nozzle_pos[2] - z_step >= z_min else start_pos[2] %}
            {% set r_val = retract_during if printer.extruder.temperature >= temp else 0 %}
            {% set f_val = nozzle_pos[6] + speed_up + r %}
            {% set ns.nozzle_pos = [start_pos[0], start_pos[1], z_val, i_val, j_val, r_val, f_val] %}
            {% set _ = tmp_points.append(ns.nozzle_pos) %}        
            {% set _ = points.extend(tmp_points) %}
        {% endfor %}

    # {% elif pattern == 3 %}    
    #     # Verbose Output: Print pattern #
    #     {% if verbose %}
    #         { action_respond_info("Pattern {}".format(
    #             (pattern),
    #         )) }
    #     {% endif %} 
        
    #     {% set r_val = retract_before if printer.extruder.temperature >= temp else 0 %}
    #     # Verbose Output: Print retraction values
    #     {% if verbose %}
    #         { action_respond_info("Retraction: Before_Wipe: {}, During_Wipe: {}, After-Wipe: {}".format(
    #             (retract_before * -1),
    #             (retract_during * -1),
    #             (retract_after * -1),
    #         )) }
    #     {% endif %}

    #     # Calculate the diameter of the brush
    #     {% set diameter = (size_x, size_y) | min %}
    #     {% set radius = diameter / 2 %}

    #     # Verbose Output:
    #     {% if verbose %}
    #        { action_respond_info("Diameter: {}, Radius: {}\nX_Min: {}, X_Max: {}".format(
    #             (diameter),
    #             (radius),
    #             (x_min),
    #             (x_max),
    #         )) }
    #     {% endif %}

    #     {% set i_val = 0 %}
    #     {% set j_val = 0 %}
    #     {% set f_val = speed %}

    #     {% if verbose %}
    #         { action_respond_info("I_Val: {}, J_val: {}, R_Val: {}, F_Val: {}".format(
    #             (i_val),
    #             (j_val),
    #             (r_val),
    #             (f_val),
    #         )) }
    #     {% endif %}

    #     # Calculate the number of steps in all directions 
    #     {% set long_points = (x_max - x_min) / step | round(1) if long_side == size_x else (y_max - y_min) / step | round(1) %}
    #     {% set short_points = (y_max - y_min) / step | round(1) if short_side == size_y else (x_max - x_min) / step | round(1) %}

    #     # Verbose Output: Print points
    #     {% if verbose %}
    #         { action_respond_info("Long_Points: {}, Short_Points: {}".format(
    #             (long_points),
    #             (short_points),
    #         )) }
    #     {% endif %}      

    #     {% set ns = namespace() %}
    #     {% set ns.nozzle_pos = [x_min, y_min, z_max, i_val, j_val, r_val, f_val] if not opposite_side else [x_max, y_min, z_max, i_val, j_val, r_val, f_val] %}
    #     {% set nozzle_pos, start_pos = ns.nozzle_pos, ns.nozzle_pos %}
    #     {% set points = [] %}
    #     {% set _ = points.append(ns.nozzle_pos) %}

    #     # Verbose Output: Print points and position
    #     {% if verbose %}
    #         { action_respond_info("Nozzle_Position: {}".format(
    #             (nozzle_pos),
    #         )) }
    #     {% endif %}      

    #     {% if verbose_points %}
    #         { action_respond_info("Starting Position: {}".format(
    #             (start_pos),
    #         )) }
    #     {% endif %}  
        
    #     {% for r in range(1 + repeat|int) %} 
    #         {% for i in range(long_points|int) %}        
    #             {% set x_val = nozzle_pos[0] + (size_y / 2) + i %}
    #             {% set y_val = nozzle_pos[1] + (size_y / 2) %}
    #             {% set i_val = (radius / 2) %}
    #             {% set j_val = (radius / 2) %}
    #             {% set z_val = ns.nozzle_pos[2] if nozzle_pos[2] != 0 else printer.toolhead.position.z %} 
    #             {% set r_val = 0 %}
    #             {% set f_val = nozzle_pos[6] %}
    #             {% set nozzle_pos = [x_val, y_val, z_val, i_val, j_val, r_val, f_val] %}
    #             {% set _ = points.append(nozzle_pos) %}

    #             {% set x_val2 = nozzle_pos[0] + (size_y / 2) + i %}
    #             {% set y_val2 = nozzle_pos[1] + (size_y / 2) %}
    #             {% set nozzle_pos2 = [x_val2, y_val2, z_val, i_val, j_val, r_val, f_val] %}
    #             {% set _ = points.append(nozzle_pos2) %}

    #             {% set x_val3 = start_pos[0] + step + i %}
    #             {% set y_val3 = start_pos[1] %}
    #             {% set nozzle_pos3 = [x_val3, y_val3, z_val, i_val, j_val, r_val, f_val] %}
    #             {% set _ = points.append(nozzle_pos3) %}
    #         {% endfor %}
    #         {% set z_val = (ns.nozzle_pos[2] - z_step) if ns.nozzle_pos[2] - z_step >= z_min else start_pos[2] %}
    #         {% set r_val = retract_during if printer.extruder.temperature >= temp else 0 %}
    #         {% set f_val = ns.nozzle_pos[6] + speed_up + r %}
    #         {% set ns.nozzle_pos = [start_pos[0], start_pos[1], z_val, i_val, j_val, r_val, f_val] %}
    #         {% set _ = points.append(ns.nozzle_pos) %}
    #     {% endfor %}
    # {% endif %}

    {% else %}
        { action_raise_error("Must choose either 1 or 2 for pattern") }
    {% endif %}

    #if not homed and auto home is set to true then home the printer
    {% if not 'xyz' in printer.toolhead.homed_axes and auto_home %}
        {% set homed = "false" %}
        G28    
        {% if verbose %}
            { action_respond_info("Homing..") }
        {% endif %}
    {% elif not 'xyz' in printer.toolhead.homed_axes and not auto_home %}
        {% set homed = "false" %}
        { action_raise_error("Printer must be homed first!") }
    {% elif 'xyz' in printer.toolhead.homed_axes %}
         {% set homed = "true" %}
    {% endif %}

    # Verbose Output: Print auto statuses
    {% if verbose %}
        { action_respond_info("Auto_Home Status: {}, Auto_Heat Status: {}. Homed_Status: {}".format(
            (auto_home),
            (auto_heat),
            (homed),
        )) }
    {% endif %}

    {% if not cold_clean %}
        {% if auto_heat and printer.extruder.temperature < temp %}
            SET_HEATER_TEMPERATURE HEATER=extruder TARGET={temp + 1}
            # Verbose Output: Print target temp
            {% if verbose %}
                { action_respond_info("Nozzle heating to: {}".format(
                    (temp),
                )) }
            {% endif %}
            TEMPERATURE_WAIT SENSOR=extruder MINIMUM={temp}
            G1 E{retract_before}
        {% endif %}
    {% endif %}

    G90
    G0 Z{z_hop}

    {% if purge > 0 %}
        KOMB_purge
    {% endif %}

    G0 Z{points[0][2]}
    G0 X{points[0][0]} Y{points[0][1]} F{travel_speed * 60}

    {% if printer.extruder.temperature >= temp and retract_before != 0 %}
        G1 E{retract_before * -1}
    {% endif %}

    # Verbose Output:
    {% if verbose_points %}
        { action_respond_info("Starting position: X: {}, Y: {}, Z: {}, R: {}, F: {}".format(
            (points[0][0]), 
            (points[0][1]), 
            (points[0][2]),
            (-points[0][5]),
            (points[0][6] * 60),
        )) }
    {% endif %}

    {% for point in points[1:] %}
        G1 X{point[0]} Y{point[1]} Z{point[2]} E{-point[5]} F{point[6] * 60}
        # Verbose Output:
        {% if verbose_points %}
            { action_respond_info("Moving to X: {}, Y: {}, Z: {}, R: {}, F: {}".format(
                (point[0]), 
                (point[1]), 
                (point[2]),
                (-point[5]), 
                (point[6] * 60), 
            )) }
        {% endif %}
        {% if pattern == 2 %}
            {% if opposite_side %}
                G3 I{point[3]} J{point[4]} 
            {% else %}
                G2 I{point[3]} J{point[4]} 
            {% endif %}
            {% if verbose_points %}
                { action_respond_info("Arcing with I: {}, J: {}".format(
                    (point[3]),
                    (point[4]),
                )) }
            {% endif %}  
        {% endif %}
        # {% elif pattern == 03 %} 
        #     G3 X{point[0]} Y{point[1]} Z{point[2]} I{point[3]} J{point[4]} E{-point[5]} F{point[6] * 60}
        #     {% if verbose_points %}
        #     { action_respond_info("Moving to X: {}, Y: {}, Z: {}\nI: {}, J: {}, R: {}, F: {}".format(
        #         (point[0]), 
        #         (point[1]), 
        #         (point[2]),
        #         (point[3]),
        #         (point[4]),
        #         (-point[5]), 
        #         (point[6] * 60), 
        #         )) }
        #     {% endif %}
        #     G2 X{point[0]} Y{point[1]} Z{point[2]} I{point[3]} J{point[4]} E{-point[5]} F{point[6] * 60}
        #     {% if verbose_points %}
        #     { action_respond_info("Moving to X: {}, Y: {}, Z: {}\nI: {}, J: {}, R: {}, F: {}".format(
        #         (point[0]), 
        #         (point[1]), 
        #         (point[2]),
        #         (point[3]),
        #         (point[4]),
        #         (-point[5]), 
        #         (point[6] * 60), 
        #         )) }
        #     {% endif %}            
        # {% endif %}
    {% endfor %}

    {% if printer.extruder.temperature >= temp and retract_after != 0 %}
        G1 E{retract_after * -1}
    {% endif %}

    # Verbose Output: Print points after movement loop
    {% if verbose %}
        { action_respond_info("KOMBing Completed!") }
    {% endif %}

    {% if return_to_start %}
        G0 Z{current_z + z_hop}
        G0 X{current_x} Y{current_y} F{travel_speed * 60}
        {% if verbose_points %}
            { action_respond_info("Returning to Starting Position:\nX: {}, Y: {}. Z: {}".format(
                (current_x),
                (current_y),
                (current_z),
            )) }
        {% endif %}
    {% endif %}

    RESTORE_GCODE_STATE NAME=clean_nozzle_state

[gcode_macro _KOMB_trigger]
variable_next_trigger: 0
description: add this macro to your slicer to enable frequency triggering.
gcode:
    SAVE_GCODE_STATE NAME=komb_trigger
    {% set height = printer.toolhead.position.z %} 
    {% set trigger_freq = printer["gcode_macro _KOMB_Variables"].trigger_freq %}

    {% if next_trigger is not defined %}
        {% set next_trigger = trigger_freq %}
    {% endif %}
 
    {% if height == next_trigger or height <= 1 %}
        SET_GCODE_VARIABLE MACRO=_KOMB_trigger VARIABLE=next_trigger VALUE={ next_trigger + trigger_freq }
        KOMB
    {% endif %}

    RESTORE_GCODE_STATE NAME=komb_trigger

[gcode_macro KOMB_purge]
gcode:
    {% set vars = printer["gcode_macro _KOMB_Variables"] %}
    {% set purge_speed = (vars.purge_speed / 5.0) * 60 | float %}
    {% if vars.purge_amount > 0 %}
        {% if not 'xyz' in printer.toolhead.homed_axes and vars.auto_home %}
            G28    
        {% elif not 'xyz' in printer.toolhead.homed_axes and not vars.auto_home %}
            { action_raise_error("Printer must be homed first!") }
        {% endif %}
        {% if printer.extruder.temperature < 170 %}
            {% if not vars.autoheat %}
                { action_raise_error("Nozzle must be heated to at least 170C for purge.") }
            {% else %}
                SET_HEATER_TEMPERATURE HEATER=extruder TARGET={vars.temp}    
                TEMPERATURE_WAIT SENSOR=extruder MINIMUM={vars.temp}                
            {% endif %}
        {% endif %}
        G0 Z{vars.purge_location_z} 
        G0 X{vars.purge_location_x} Y{vars.purge_location_y} F{vars.travel_speed * 60}
        G1 E{vars.purge_amount} F{purge_speed}
        G92 E0
        G4 P{vars.wait_time * 1000} 
    {% else %}
       { action_raise_error("A purge amount greater than 0 must be defined") }
    {% endif %} 

[gcode_macro BRUSH]
gcode:
   KOMB
##################################################################################################################################################
##################################################################################################################################################

#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [extruder]
#*# control = pid
#*# pid_kp = 37.356
#*# pid_ki = 10.377
#*# pid_kd = 33.621
#*#
#*# [heater_bed]
#*# control = pid
#*# pid_kp = 70.751
#*# pid_ki = 1.310
#*# pid_kd = 955.138
#*#
#*# [bed_mesh default]
#*# version = 1
#*# points =
#*# 	0.303293, 0.169543, 0.103293, 0.080793, 0.095793
#*# 	0.199543, 0.060793, 0.019543, 0.024543, 0.050793
#*# 	0.172043, 0.042043, -0.000457, 0.007043, 0.047043
#*# 	0.199543, 0.064543, 0.024543, 0.020793, 0.037043
#*# 	0.227043, 0.102043, 0.064543, 0.044543, 0.045793
#*# x_count = 5
#*# y_count = 5
#*# mesh_x_pps = 4
#*# mesh_y_pps = 4
#*# algo = bicubic
#*# tension = 0.2
#*# min_x = 8.0
#*# max_x = 223.0
#*# min_y = 30.0
#*# max_y = 201.0
